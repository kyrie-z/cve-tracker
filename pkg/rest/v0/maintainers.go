package v0

import (
	"cve-tracker/pkg/db"
	"cve-tracker/pkg/utils"
	"fmt"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
)

/*
Initialize the list of maintainers (json format)
*/
func initMaintainer(c *gin.Context) {
	product := c.Param("product")
	if len(product) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid product"})
		return
	}
	file, err := c.FormFile("maintainer")
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	dst := fmt.Sprintf("./data/%s-init-maintainer", product)
	err = c.SaveUploadedFile(file, dst)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	err = db.SyncMaintainerDate(dst, product)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	(&db.Log{
		Product:     product,
		Operator:    c.GetString("username"),
		Action:      db.LogActionInitMaintainerInfo,
		Description: db.LogActionInitMaintainerInfo.String(),
		Content:     db.LogActionInitMaintainerInfo.String(),
		Time_at:     time.Now().Format("2006-01-02 15:04:05"),
	}).InsertLog()

	c.JSON(http.StatusOK, "init maintainer ...")

}

//Query maintainer list
func queryMaintainerList(c *gin.Context) {
	product := c.Param("product")
	if len(product) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid product"})
		return
	}
	var params = make(map[string]string)
	if pkg := c.Query("package"); len(pkg) != 0 {
		params["package"] = pkg
	}
	if maintainer := c.Query("maintainer"); len(maintainer) != 0 {
		params["maintainer"] = maintainer
	}
	if area := c.Query("area"); len(area) != 0 {
		params["area"] = area
	}
	list, total, err := db.GetMaintainerList(params, product)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error})
		return
	}

	c.Header("X-Resource-Total", fmt.Sprint(total))
	c.JSON(http.StatusOK, list)
}

//Update maintainer info
func updateMaintainer(c *gin.Context) {
	product := c.Param("product")
	if len(product) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid product"})
		return
	}
	var values = make(map[string]string)
	err := c.ShouldBind(&values)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	if len(values) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "no data has bind"})
		return
	}
	value, ok := values["package"]
	if !ok || len(value) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "no package data has error"})
		return
	}

	maintainerInfo, err := db.GetMaintainerInfo(values["package"], product)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": "maintainer information cannot be found in the database"})
		return
	}
	err = maintainerInfo.Update(values, product)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": err.Error(),
		})
		return
	}
	(&db.Log{
		Product:     product,
		Operator:    c.GetString("username"),
		Action:      db.LogActionModifyMaintainerInfo,
		Target:      values["package"],
		Description: db.LogActionModifyMaintainerInfo.String() + ": " + values["package"],
		Content:     utils.ToString(values),
		Time_at:     time.Now().Format("2006-01-02 15:04:05"),
	}).InsertLog()

	c.JSON(http.StatusOK, maintainerInfo)

}

// add new package maintainer info
func addMaintainer(c *gin.Context) {
	product := c.Param("product")
	if len(product) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid product"})
		return
	}
	var info db.Maintainer
	err := c.ShouldBind(&info)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": err.Error()})
		return
	}

	info.FirstOrCreate(product)

	(&db.Log{
		Product:     product,
		Operator:    c.GetString("username"),
		Action:      db.LogActionCreateMaintainerInfo,
		Target:      info.Package,
		Description: db.LogActionCreateMaintainerInfo.String() + ": " + info.Package,
		Content:     utils.ToString(info),
		Time_at:     time.Now().Format("2006-01-02 15:04:05"),
	}).InsertLog()

	c.JSON(http.StatusOK, info)

}
