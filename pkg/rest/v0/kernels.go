package v0

import (
	"cve-tracker/pkg/db"
	"cve-tracker/pkg/utils"
	"fmt"
	"net/http"
	"os"
	"strconv"
	"strings"
	"time"

	"github.com/PuerkitoBio/goquery"
	"github.com/gin-gonic/gin"
)

//Query kernel CVE list
func queryKernelList(c *gin.Context) {
	product := c.Param("product")
	if len(product) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid product"})
		return
	}
	var params = make(map[string]interface{})
	if cve := c.Query("cve"); len(cve) != 0 {
		params["cve"] = cve
	}
	release := c.DefaultQuery("release", "4.19")
	params["release"] = release

	if status := c.Query("status"); len(status) != 0 {
		params["status"] = strings.Split(status, ",")
	}
	if integrate_version := c.Query("integrate_version"); len(integrate_version) != 0 {
		params["integrate_version"] = strings.Split(integrate_version, ",")
	}
	if score := c.Query("score"); len(score) != 0 {
		params["score"] = score
	}
	sort := c.DefaultQuery("sort", "score")
	if !db.ValidKey(sort) {
		sort = "score"
	}
	params["sort"] = sort

	pageStr := c.DefaultQuery("page", "1")
	page, _ := strconv.Atoi(pageStr)
	countStr := c.DefaultQuery("count", "20")
	count, _ := strconv.Atoi(countStr)
	infos, total, err := db.GetKernelList(params, (page-1)*count, count, product)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": err.Error(),
		})
		return
	}
	c.Header("X-Current-Page", fmt.Sprint(page))
	c.Header("X-Resource-Total", fmt.Sprint(total))
	c.Header("X-Page-Size", fmt.Sprint(count))
	c.JSON(http.StatusOK, infos)

}

// Update kernle CVE information
func updateKernelCVE(c *gin.Context) {
	product := c.Param("product")
	if len(product) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid product"})
		return
	}
	var values = make(map[string]interface{})
	err := c.ShouldBind(&values)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	if len(values) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "no data has bind"})
		return
	}
	value, ok := values["cve"].(string)
	if !ok || len(value) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "no cve info has error"})
		return
	}
	value, ok = values["release"].(string)
	if !ok || len(value) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "no release info has error"})
		return
	}
	value, ok = values["status"].(string)
	if !ok || len(value) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "no status data has error"})
		return
	}
	cveInfo, err := db.GetKernelCveInfo(values["cve"].(string), values["release"].(string), product)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": "CVE information cannot be found in the database",
		})
		return
	}
	if cveInfo.Status != "fixed" && values["status"].(string) == "fixed" {
		values["repairer"] = c.GetString("username")
		values["fix_at"] = time.Now().Format("2006/01/02")
	}

	err = cveInfo.Update(values, product)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	(&db.Log{
		Operator:    c.GetString("username"),
		Action:      db.LogActionModifyCVE,
		Target:      values["cve"].(string),
		Description: db.LogActionModifyCVE.String() + ": " + values["cve"].(string),
		Content:     utils.ToString(values),
		Time_at:     time.Now().Format("2006-01-02 15:04:05"),
	}).InsertLog()

	c.JSON(http.StatusOK, cveInfo)

}

const (
	nvdPrefix       = "https://nvd.nist.gov/vuln/detail/"
	linuxkernelcves = "https://github.com/nluedtke/linux_kernel_cves/blob/master/data/"
)

// Synchronize upstream kernel CVE information
func syncKernelCVE(c *gin.Context) {
	var params = make(map[string]interface{})
	product := c.Param("product")
	if len(product) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid product"})
		return
	}
	release := c.Query("release")
	if len(release) != 0 {
		params["release"] = release
	} else {
		c.JSON(http.StatusBadRequest, gin.H{"error": "no release"})
		return
	}
	go func(release string) {
		fmt.Println("update kernel begin...")
		infos, err := db.Fetch_linux(linuxkernelcves, release)
		if err != nil {
			c.JSON(http.StatusBadRequest, gin.H{
				"error": err.Error(),
			})
			return
		}

		for i := 0; i < len(infos); i++ {
			infos[i].Score, infos[i].Cvss, _ = fecthNVDCore(infos[i].Cve)
			//插入
			infos[i].FirstOrCreate(product)
		}
		fmt.Println("update kernel done...")
	}(release)
	(&db.Log{
		Operator:    c.GetString("username"),
		Action:      db.LogActionSyncUpstream,
		Description: "update linux list",
		Content:     c.GetString("username"),
		Time_at:     time.Now().Format("2006-01-02 15:04:05"),
	}).InsertLog()
	c.String(http.StatusAccepted, "")
}

func fecthNVDCore(id string) (float64, int, error) {
	res, err := http.Get(nvdPrefix + id)
	if err != nil {
		return 0, 0, err
	}
	defer res.Body.Close()
	if res.StatusCode != 200 {
		return 0, 0, fmt.Errorf("status code error: %d %s", res.StatusCode, res.Status)
	}
	doc, err := goquery.NewDocumentFromReader(res.Body)
	if err != nil {
		return 0, 0, err
	}
	var vb string
	var score float64
	cvss := 1
	var flag int
	doc.Find("span").Each(func(i int, s *goquery.Selection) {
		s.Find("span").Each(func(cellIdx int, cellEle *goquery.Selection) {
			band := cellEle.Find("a").Text()
			if strings.Contains(band, "HIGH") || strings.Contains(band, "MEDIUM") || strings.Contains(band, "CRITICAL") || strings.Contains(band, "LOW") {
				cvss += 1
				if flag == 0 {
					vb = strings.Replace(band[:4], " ", "", -1)
					score, _ = strconv.ParseFloat(vb, 64)
					flag = 1
				}
			}
		})
	})
	if cvss >= 4 {
		cvss = 3
	} else if cvss == 1 {
		cvss = 0
	}
	return score, cvss, nil
}

func initIntegrateVersion(c *gin.Context) {
	product := c.Param("product")
	if len(product) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid product"})
		return
	}

	file, err := c.FormFile("integrate-version")
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	path, _ := os.Getwd()
	dst := fmt.Sprintf("%s/data/%s-kernel-integrate-version", path, product)
	err = c.SaveUploadedFile(file, dst)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	err = db.SyncIntergrateVersion(dst, product)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	c.JSON(http.StatusOK, "init kernel integrate version ...")
}
