package v0

import (
	"cve-tracker/pkg/db"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
)

func Router(addr string) error {
	var eng = gin.Default()
	eng.Use(cors())
	v0 := eng.Group("v0")
	session := v0.Group("/session")
	{
		session.POST("/login", login)     //curl -v -X POST http://127.0.0.1:10808/v0/session/login -H 'Content-Type:application/json' -d'{"account":"","password":""}'
		session.DELETE("/logout", logout) //curl -v -X DELETE http://127.0.0.1:10808/v0/session/logout  -H 'Authorization:'
	}
	cves := v0.Group("/cves")
	{
		cves.GET("/:product", queryCVEList)          //curl -X GET http://127.0.0.1:10808/v0/cves/v20?package=linu&status=unprocessed,fixed&count=3&debian_buster_status=open&score=5-4&sort=updated_at
		cves.PUT("/:product", checkToken, updateCVE) //curl -X PUT http://127.0.0.1:10808/v0/cves/v20 -H 'Content-Type:application/json' -d '{"cve":"CVE-2007-1614","package":"zziplib","status":"fixed"}'

		cves.POST("/:product/sync", syncUpstream) // 同步上游 测试
		cves.GET("/:product/export", exportCVE)   //导出对外 curl -X GET http://127.0.0.1:10808/v0/cves/v20/export
	}
	kernels := v0.Group("/kernels")
	{
		kernels.GET("/:product", queryKernelList)
		kernels.PUT("/:product", checkToken, updateKernelCVE)
		kernels.POST("/:product/sync", checkToken, syncKernelCVE)
	}

	tools := v0.Group("/tools")
	{
		tools.GET("/package/:product", getPrepackageList)          //curl -X GET localhost:10808/v0/tools/package/v20
		tools.POST("/package/:product/:release", reloadPrepackage) //curl -X POST localhost:10808/v0/tools/package/v20/desktop -F 'pre-package=@./os'
		tools.POST("/binary/:product", reloadBinaryList)           //curl -X POST localhost:10808/v0/tools/binary/v20 -F 'binary=@./source-binary'
		tools.POST("/package/:product/maintainer", initMaintainer)
		tools.GET("/logs", queryLogList)
	}
	return eng.Run(addr)
}

//middleware, for token verification.
func checkToken(c *gin.Context) {
	token := c.GetHeader("Authorization")
	if len(token) == 0 {
		c.AbortWithStatus(http.StatusUnauthorized)
	}
	tk := db.Session{Token: token}
	err := tk.Get()
	if err != nil {
		c.AbortWithStatus(http.StatusUnauthorized)
	}
	if tk.Expires > time.Now().Unix() {
		tk.Delete()
		c.AbortWithStatus(http.StatusUnauthorized)
	}

	c.Set("username", tk.Username)
}

func cors() gin.HandlerFunc {
	return func(c *gin.Context) {
		if len(c.Request.Header.Get("Origin")) != 0 {
			c.Header("Access-Control-Allow-Origin", "*")
			c.Header("Access-Control-Allow-Headers", "*")
			// c.Header("Access-Control-Allow-Methods", "POST, GET, OPTIONS, PUT, DELETE, PATCH")
			// //c.Header("Access-Control-Allow-Headers", "Authorization, Content-Length, X-CSRF-Token, Accept, Origin, Host, Connection, Accept-Encoding, Accept-Language,DNT, X-CustomHeader, Keep-Alive, User-Agent, X-Requested-With, If-Modified-Since, Cache-Control, Content-Type, Pragma, Timestamp, timestamp")
			// // expose custom header
			// c.Header("Access-Control-Expose-Headers", "Content-Length, Access-Control-Allow-Origin, Access-Control-Allow-Headers, Content-Type, X-Current-Page, X-Resource-Total, X-Page-Size, Access-Token,Authority")
			// c.Set("Content-type", "application/json; charset=utf-8")
		}

		if c.Request.Method == http.MethodOptions {
			c.JSON(http.StatusOK, "Options Request!")
			return
		}
		c.Next()
	}
}
