package v0

import (
	"cve-tracker/pkg/db"
	"net/http"
	"time"

	"github.com/gin-gonic/gin"
)

func Router(addr string) error {
	var eng = gin.Default()
	eng.Use(cors())
	v0 := eng.Group("v0")
	session := v0.Group("/session")
	{
		session.POST("/login", login)     //curl -v -X POST http://127.0.0.1:10808/v0/session/login -H 'Content-Type:application/json' -d'{"account":"","password":""}'
		session.DELETE("/logout", logout) //curl -v -X DELETE http://127.0.0.1:10808/v0/session/logout  -H 'Authorization:'
	}
	cves := v0.Group("/cves")
	{
		cves.GET("/:product", checkToken, queryCVEList) //curl -X GET http://127.0.0.1:10808/v0/cves/v20?package=linu&status=unprocessed,fixed&count=3&debian_buster_status=open&score=5-4&sort=updated_at
		cves.PUT("/:product", checkToken, updateCVE)    //curl -X PUT http://127.0.0.1:10808/v0/cves/v20 -H 'Content-Type:application/json' -d '{"cve":"CVE-2007-1614","package":"zziplib","status":"fixed"}'

		cves.POST("/sync/:product", syncUpstream) // 同步上游  curl -X POST localhost:10808/v0/cves/sync/v20 -F 'upstream=@./debian-cve'
		cves.GET("/export/:product", exportCVE)   //导出对外 curl -X GET http://127.0.0.1:10808/v0/cves/export/v20
	}
	kernels := v0.Group("/kernels")
	{
		kernels.GET("/:product", queryKernelList) //curl -X GET localhost:10808/v0/kernels/v20?release=4.19&cve=CVE-2019-17133
		kernels.PUT("/:product", updateKernelCVE)
		kernels.POST("/sync/:product", syncKernelCVE) //curl -X POST localhost:10808/v0/kernels/sync/v20?release=4.19
		kernels.POST("/integrate-version/:product", initIntegrateVersion)
	}
	packages := v0.Group("/packages")
	{
		packages.GET("/preinstall/:product", getPrepackageList)          //curl -X GET localhost:10808/v0/packages/preinstall/v20
		packages.POST("/preinstall/:product/:release", reloadPrepackage) //curl -X POST localhost:10808/v0/packages/preinstall/v20/desktop -F 'pre-package=@./os'
		packages.POST("/binary/:product", reloadBinaryList)              //curl -X POST localhost:10808/v0/packages/binary/v20 -F 'binary=@./source-binary'

	}
	maintainers := v0.Group("/maintainers")
	{
		maintainers.POST("/:product", initMaintainer)     //curl -X POST localhost:10808/v0/maintainers/v20 -F 'maintainer=@./maintainer'
		maintainers.GET("/:product", queryMaintainerList) //curl -X GET localhost:10808/v0/maintainers/v20?area=西安地区
		maintainers.PUT("/:product", updateMaintainer)    //curl -X PUT http://127.0.0.1:10808/v0/maintainers/v20/list -H 'Content-Type:application/json' -d '[{"package":"zziplib"}]'
		maintainers.POST("/add/:product", addMaintainer)  //curl -X POST http://127.0.0.1:10808/v0/maintainers/add/v20 -H 'Content-Type:application/json' -d '{"package":"zziplib","area":"西安地区"}'
	}

	tools := v0.Group("/tools")
	{
		tools.GET("/logs", queryLogList)       //curl -X GET localhost:10808/v0/tools/logs
		tools.GET("/count/:product", getCount) //curl -X GET localhost:10808/v0/tools/count/v20
	}
	return eng.Run(addr)
}

//middleware, for token verification.
func checkToken(c *gin.Context) {
	token := c.GetHeader("Authorization")
	if len(token) == 0 {
		c.AbortWithStatus(http.StatusUnauthorized)
		return
	}
	/*
		Don't trust the token returned by the client,
		Only trust the token stored in the database.
	*/
	tk := db.Session{Token: token}
	err := tk.Get()
	if err != nil {
		c.AbortWithStatus(http.StatusUnauthorized)
		return
	}

	if tk.Expires < time.Now().Unix() {
		tk.Delete()
		c.AbortWithStatus(http.StatusUnauthorized)
		return
	}

	c.Set("username", tk.Username)
}

func cors() gin.HandlerFunc {
	return func(c *gin.Context) {
		if len(c.Request.Header.Get("Origin")) != 0 {
			c.Header("Access-Control-Allow-Origin", "*")
			c.Header("Access-Control-Allow-Headers", "*")
			c.Header("Access-Control-Allow-Methods", "POST, GET, OPTIONS, PUT, DELETE")
			c.Header("Access-Control-Allow-Headers", "Authorization, Content-Length, X-CSRF-Token, Accept, Origin, Host, Connection, Accept-Encoding, Accept-Language,DNT, X-CustomHeader, Keep-Alive, User-Agent, X-Requested-With, If-Modified-Since, Cache-Control, Content-Type, Pragma, Timestamp, timestamp")
			// // expose custom header
			c.Header("Access-Control-Expose-Headers", "Content-Length, Access-Control-Allow-Origin, Access-Control-Allow-Headers, Content-Type, X-Current-Page, X-Resource-Total, X-Page-Size,authorization")
			c.Set("Content-type", "application/json; charset=utf-8")
		}

		if c.Request.Method == http.MethodOptions {
			c.JSON(http.StatusOK, "Options Request!")
			return
		}
		c.Next()
	}
}
