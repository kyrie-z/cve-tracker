package v0

import (
	"cve-tracker/pkg/db"
	"cve-tracker/pkg/utils"
	"fmt"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
)

/*
Query cve vulnerabilities by key.
Support key include: cve, package, status, pre_installed, score(range `0-10`), debian_buster_status, sort(time or score), page, count
*/
func queryCVEList(c *gin.Context) {
	product := c.Param("product")
	if len(product) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid product"})
		return
	}
	var params = make(map[string]interface{})
	if cve := c.Query("cve"); len(cve) != 0 {
		params["cve"] = cve
	}
	if pkg := c.Query("package"); len(pkg) != 0 {
		params["package"] = pkg
	}
	if status := c.Query("status"); len(status) != 0 {
		params["status"] = strings.Split(status, ",")
	}
	if pre_installed := c.Query("pre_installed"); len(pre_installed) != 0 {
		params["pre_installed"] = strings.Split(pre_installed, ",")
	}
	if score := c.Query("score"); len(score) != 0 {
		params["score"] = score
	}
	if debian_buster_status := c.Query("debian_buster_status"); len(debian_buster_status) != 0 {
		params["debian_buster_status"] = strings.Split(debian_buster_status, ",")
	}
	//地域查询
	if area := c.Query("area"); len(area) != 0 {
		params["area"] = strings.Split(area, ",")
	}
	//与我相关
	// onlyme := c.DefaultQuery("onlyme", "false")
	// params["onlyme"] = onlyme
	// if c.GetString("username") == "" && onlyme == "true" {
	// 	c.JSON(http.StatusBadRequest, gin.H{"error": "please login first"})
	// 	return
	// }
	// params["username"] = c.GetString("username")
	if maintainer := c.Query("maintainer"); len(maintainer) != 0 {
		params["maintainer"] = maintainer
	}

	sort := c.DefaultQuery("sort", "score")
	if !db.ValidKey(sort) {
		sort = "score"
	}
	params["sort"] = sort
	pageStr := c.DefaultQuery("page", "1")
	page, _ := strconv.Atoi(pageStr)
	countStr := c.DefaultQuery("count", "20")
	count, _ := strconv.Atoi(countStr)

	list, total, err := db.GetCVEList(params, (page-1)*count, count, product)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error})
		return
	}
	//area地区赋值
	for _, v := range list {
		maintainerInfo, err := db.GetMaintainerInfo(v.Package, product)
		if err != nil {
			fmt.Printf("[IMPORT] '%s' isn't on the maintainer list\n", v.Package)
		} else {
			v.Area = maintainerInfo.Area
			v.Maintainer = maintainerInfo.Maintainer
		}
	}

	c.Header("X-Current-Page", fmt.Sprint(page))
	c.Header("X-Resource-Total", fmt.Sprint(total))
	c.Header("X-Page-Size", fmt.Sprint(count))
	c.JSON(http.StatusOK, list)
}

//query CVE by id
func queryCVE(c *gin.Context) {
	product := c.Param("product")
	if len(product) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid product"})
		return
	}
	id := c.Param("id")
	if len(id) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid cve id"})
		return
	}
	cveList, err := db.GetCVE(id, product)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	c.JSON(http.StatusOK, cveList)
}

//update
func updateCVE(c *gin.Context) {
	product := c.Param("product")
	if len(product) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid product"})
		return
	}
	var values = make(map[string]interface{})
	err := c.ShouldBind(&values)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	if len(values) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "no data has bind"})
		return
	}

	value, ok := values["cve"].(string)
	if !ok || len(value) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "no cve data has error"})
		return
	}
	value, ok = values["package"].(string)
	if !ok || len(value) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "no package data has error"})
		return
	}
	value, ok = values["status"].(string)
	if !ok || len(value) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "no status data has error"})
		return
	}
	//Delete irrelevant information about cve
	delete(values, "area")
	delete(values, "maintainer")

	cveInfo, err := db.GetcveInfo(values["cve"].(string), values["package"].(string), product)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": "CVE information cannot be found in the database",
		})
		return
	}
	if cveInfo.Status != "fixed" && values["status"].(string) == "fixed" {
		values["repairer"] = c.GetString("username")
		values["fix_at"] = time.Now().Format("2006/01/02")
	}

	err = cveInfo.Update(values, product)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	(&db.Log{
		Product:     product,
		Operator:    c.GetString("username"),
		Action:      db.LogActionModifyCVE,
		Target:      values["cve"].(string),
		Description: db.LogActionModifyCVE.String() + ": " + values["cve"].(string),
		Content:     utils.ToString(values),
		Time_at:     time.Now().Format("2006-01-02 15:04:05"),
	}).InsertLog()

	c.JSON(http.StatusOK, cveInfo)
}

/*
Save sync-upstream file and update to database.
*/
func syncUpstream(c *gin.Context) {
	product := c.Param("product")
	if len(product) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid product"})
		return
	}
	file, err := c.FormFile("upstream")
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	dst := fmt.Sprintf("./data/%s-sync-upstream", product)
	err = c.SaveUploadedFile(file, dst)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	//读取并写入数据库
	err = db.SyncDate(dst, product)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	(&db.Log{
		Operator:    c.GetString("username"),
		Action:      db.LogActionSyncUpstream,
		Description: "update all cve",
		Content:     "update all cve",
		Time_at:     time.Now().Format("2006-01-02 15:04:05"),
	}).InsertLog()

	c.String(http.StatusAccepted, "sync upstream ...")

}

/*
Export interface includes cve info and binary info. For Security Department
*/
func exportCVE(c *gin.Context) {
	product := c.Param("product")
	if len(product) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{"error": "invalid product"})
		return
	}
	cveList, total, err := db.GetAllCVE(product)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	binList, err := db.GetAllBinary(product)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}
	exCVE := db.IntegrateCVE(cveList, binList)
	c.Header("X-Page-Size", fmt.Sprint(total))
	c.JSON(http.StatusOK, exCVE)
}
