package v0

import (
	"cve-tracker/pkg/db"
	"cve-tracker/pkg/utils"
	"fmt"
	"net/http"
	"strconv"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
)

/*
Query cve vulnerabilities by key.
Support key include: cve, package, status, pre_installed, score(range `0-10`), debian_buster_status, sort(time or score), page, count
*/
func queryCVEList(c *gin.Context) {
	product := c.Param("product")
	if len(product) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": "invalid product",
		})
		return
	}
	var params = make(map[string]interface{})
	if cve := c.Query("cve"); len(cve) != 0 {
		params["cve"] = cve
	}
	if pkg := c.Query("package"); len(pkg) != 0 {
		params["package"] = pkg
	}
	if status := c.Query("status"); len(status) != 0 {
		params["status"] = strings.Split(status, ",")
	}
	if pre_installed := c.Query("pre_installed"); len(pre_installed) != 0 {
		params["pre_installed"] = strings.Split(pre_installed, ",")
	}
	if score := c.Query("score"); len(score) != 0 {
		params["score"] = score
	}
	if debian_buster_status := c.Query("debian_buster_status"); len(debian_buster_status) != 0 {
		params["debian_buster_status"] = debian_buster_status
	}
	sort := c.DefaultQuery("sort", "score")
	if !db.ValidKey(sort) {
		sort = "score"
	}
	params["sort"] = sort
	pageStr := c.DefaultQuery("page", "1")
	page, _ := strconv.Atoi(pageStr)
	countStr := c.DefaultQuery("count", "15")
	count, _ := strconv.Atoi(countStr)

	list, total, err := db.GetCVEList(params, (page-1)*count, count, product)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error})
		return
	}
	c.Header("X-Current-Page", fmt.Sprint(page))
	c.Header("X-Resource-Total", fmt.Sprint(total))
	c.Header("X-Page-Size", fmt.Sprint(count))
	c.JSON(http.StatusOK, list)
}

func updateCVE(c *gin.Context) {
	product := c.Param("product")
	if len(product) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": "invalid product",
		})
		return
	}
	var values = make(map[string]interface{})
	err := c.ShouldBind(&values)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": err.Error()})
		return
	}
	if len(values) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": "no data has bind",
		})
		return
	}

	value, ok := values["cve"].(string)
	if !ok || len(value) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": "no cve data has error",
		})
		return
	}
	value, ok = values["package"].(string)
	if !ok || len(value) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": "no package data has error",
		})
		return
	}
	value, ok = values["status"].(string)
	if !ok || len(value) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": "no status data has error",
		})
		return
	}
	cveInfo, err := db.GetcveInfo(values["cve"].(string), values["package"].(string), product)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": "CVE information cannot be found in the database",
		})
		return
	}
	err = cveInfo.Update(values, product)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{
			"error": err.Error(),
		})
		return
	}
	(&db.Log{
		Product:     product,
		Operator:    c.GetString("username"),
		Action:      db.LogActionModifyCVE,
		Target:      values["cve"].(string),
		Description: db.LogActionModifyCVE.String() + ": " + values["cve"].(string),
		Content:     utils.ToString(values),
		Time_at:     time.Now().Format("2006-01-02 15:04:05"),
	}).InsertLog()

	c.JSON(http.StatusOK, cveInfo)
}
