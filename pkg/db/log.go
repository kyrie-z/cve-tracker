package db

import "fmt"

// ActionType action types
type ActionType int

// Log operation records
type Log struct {
	ID          int        `gorm:"auto_increment;primary_key" json:"id"`
	Product     string     `json:"product"`
	Operator    string     `json:"operator"`
	Action      ActionType `json:"action"`
	ActionDesc  string     `gorm:"-" json:"action_desc"`
	Target      string     `json:"target"`
	Description string     `json:"description"`
	Content     string     `json:"content" gorm:"type:text"`
	Time_at     string     `json:"time_at" gorm:"type:varchar(40)"`
}

// LogList log list
type LogList []*Log

const (
	LogActionInitPackage ActionType = iota + 1
	LogActionSyncUpstream
	LogActionModifyCVE
	LogActionPatchCVEProcess
	LogActionCRPUpdate
	LogActionLogin
	LogActionLogout
	LogActionModifyRole
	LogActionNewVersion
	LogActionPatchVersion
	LogActionDeleteVersion
	LogActionFetchScore
	LogActionCreateCVE
	LogActionInitBinary
	LogActionInitMaintainerInfo
	LogActionModifyMaintainerInfo
	LogActionCreateMaintainerInfo
)

// ValidAction validity action
func ValidAction(action int) bool {
	a := ActionType(action)
	return a >= LogActionInitPackage && a <= LogActionCreateMaintainerInfo
}

// String action description
func (action ActionType) String() string {
	switch action {
	case LogActionInitPackage:
		return "Init package list"
	case LogActionInitBinary:
		return "Init binary list"
	case LogActionSyncUpstream:
		return "Sync upstream cve"
	case LogActionModifyCVE:
		return "Modify cve"
	case LogActionCreateCVE:
		return "Create cve"
	case LogActionInitMaintainerInfo:
		return "Init Maintainer Info"
	case LogActionModifyMaintainerInfo:
		return "Modify Maintainer Info"
	case LogActionCreateMaintainerInfo:
		return "Create Maintainer Info"
	case LogActionLogin:
		return "Login"
	case LogActionLogout:
		return "Logout"
	case LogActionModifyRole:
		return "Modify Role"
	case LogActionPatchCVEProcess:
		return "Patch CVE Process"
	case LogActionCRPUpdate:
		return "CRP Update"
	}
	fmt.Printf("[LOG] undefined operation '%d' , please check log type.\n ", action)
	return "undefined operation"
}

func (list LogList) Len() int {
	return len(list)
}

// Create insert log
func (l *Log) InsertLog() error {
	db := getCommonHandle()
	return db.Create(l).Error
}

// Getist query log list, available params: product, operator, target
func GetLogList(params map[string]interface{}, offset, limit int) (int64, LogList, error) {
	db := getCommonHandle()
	var sql = db.Model(&Log{})
	if v, ok := params["product"]; ok {
		sql = sql.Where("`product` = ?", v)
	}
	if v, ok := params["operator"]; ok {
		sql = sql.Where("`operator` = ?", v)
	}
	if v, ok := params["target"]; ok {
		sql = sql.Where("`target` = ?", v)
	}
	if v, ok := params["action"]; ok {
		sql = sql.Where("`action` = ?", v)
	}
	sql = sql.Order("id desc")

	var list LogList
	var total int64
	err := sql.Count(&total).Offset(offset).Limit(limit).Find(&list).Error
	if err != nil {
		return 0, nil, err
	}
	for _, info := range list {
		info.ActionDesc = info.Action.String()
	}

	return total, list, nil
}
