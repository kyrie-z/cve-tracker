package db

import (
	"fmt"

	"cve-tracker/pkg/config"

	"github.com/jinzhu/gorm"
	_ "github.com/jinzhu/gorm/dialects/mysql"
)

var (
	handle       *gorm.DB
	productDBSet = make(map[string]*gorm.DB)
)

/*
First,link the 'common' database,including the session, product and log.
Each product has its own vulnerability database, traverse it in order to link
and save the returned db handle.
*/
func DBInit(m config.Mysql) {
	var err error
	dbcon := fmt.Sprintf("%s:%s@tcp(%s:%d)/%s?parseTime=true&loc=Local", m.User, m.Password, m.Host, m.Port, m.Dbname)
	handle, err = gorm.Open("mysql", dbcon)
	if err != nil {
		panic(err)
	}

	handle.SingularTable(true) //Disable plurals

	handle.AutoMigrate(&Session{})
	handle.AutoMigrate(&Product{})
	handle.AutoMigrate(&Employee{})
	handle.AutoMigrate(&Log{})
	handle.AutoMigrate(&Authority{})
	handle.DB().SetMaxIdleConns(10)
	handle.DB().SetMaxOpenConns(100)
	var product ProductList
	err = product.GetList()
	if err != nil {
		panic(err)
	}
	for _, pro := range product {
		err = setHandle(pro, m)
		if err != nil {
			panic(err)
		}
	}

}

func setHandle(p *Product, m config.Mysql) error {
	dbcon := fmt.Sprintf("%s:%s@tcp(%s:%d)/%s?parseTime=true&loc=Local", m.User, m.Password, m.Host, m.Port, p.Product)
	db, err := gorm.Open("mysql", dbcon)
	if err != nil {
		return err
	}

	db.SingularTable(true) //Disable plurals
	if p.Product == "v20" {
		db.AutoMigrate(&CVE{})
		db.AutoMigrate(&Kernel{})
		db.AutoMigrate(&Package{})
		db.AutoMigrate(&Binary{})
		db.AutoMigrate(&Maintainer{})
		// 	 db.AutoMigrate(&UT{})
	}
	// if p.Product == "kongxx" {

	// }
	db.DB().SetMaxIdleConns(10)
	db.DB().SetMaxOpenConns(100)
	productDBSet[p.Product] = db
	return nil
}

func getHandle(product string) *gorm.DB {
	if db, ok := productDBSet[product]; !ok {
		return nil
	} else {
		return db
	}
}

func getCommonHandle() *gorm.DB {
	return handle
}
