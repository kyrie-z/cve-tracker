package db

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"strconv"
	"strings"
	"sync"
	"time"
)

const (
	// CVE status available values
	CVEStatusUnprocessed = "unprocessed" // 未处理
	CVEStatusProcessing  = "processing"  // 处理中
	CVEStatusHold        = "hold"        // 搁置
	CVEStatusCanceled    = "canceled"    // 取消
	CVEStatusFixed       = "fixed"       // 完成
	CVEStatusPushed      = "pushed"      // 推送
)

var (
	syncLock sync.Mutex
)

// INDEX storage update time and creation time
type INDEX struct {
	//	ID        uint       `json:"-"`
	CreatedAt time.Time  `json:"created_at"`
	UpdatedAt time.Time  `json:"updated_at"`
	DeletedAt *time.Time `json:"-"`
}

// CVE store cve bug for tracking
type CVE struct {
	Cve                    string  `gorm:"primary_key" json:"cve"`
	Package                string  `json:"package" gorm:"primary_key"`
	Pre_installed          string  `json:"pre_installed"`
	Status                 string  `json:"status" gorm:"type:varchar"`
	Description            string  `json:"description" `
	Cvss                   int     `json:"cvss,string"`
	Score                  float64 `json:"score,string"`
	Repairer               string  `json:"repairer"`
	Fixed_version          string  `json:"fixed_version" gorm:"type:varchar(255)"`
	Fix_at                 string  `json:"fix_at" gorm:"type:varchar"`
	Patch_local            string  `json:"patch_local"`
	Patch_upstream         string  `json:"patch_upstream"`
	Poc                    string  `json:"poc"`
	Testpoint              string  `json:"testpoint"`
	Integrate_version      string  `json:"integrate_version"`
	Integrate_at           string  `json:"integrate_at" gorm:"type:varchar"`
	Cve_description        string  `json:"cve_description" gorm:"type:text"`
	Debian_buster_version  string  `json:"debian_buster_version"`
	Debian_buster_status   string  `json:"debian_buster_status"`
	Upstream_fixed_version string  `json:"upstream_fixed_version"`
	INDEX
}

type CVEList []*CVE

func GetCVEList(params map[string]interface{}, offset, count int, product string) (CVEList, int64, error) {
	db := getHandle(product)
	if db == nil {
		return nil, 0, fmt.Errorf("No db handler found for product '%s'", product)
	}
	db = db.Table("cve")
	var fuzzMatchList = []string{"cve", "package"}
	for _, key := range fuzzMatchList {
		if param, ok := params[key]; ok {
			db = db.Where((fmt.Sprintf("`%s` LIKE '%%%s%%'", key, param.(string))))
		}
	}
	var multipleChoice = []string{"status", "pre_installed"}
	for _, key := range multipleChoice {
		if param, ok := params[key].([]string); ok {
			fmt.Println(param)
			db = db.Where(fmt.Sprintf("`%s` in (?)", key), param)
		}
	}
	if scoreStr, ok := params["score"].(string); ok {
		scoreArr := strings.Split(scoreStr, "-")
		if len(scoreArr) == 1 {
			num, err := strconv.ParseFloat(scoreArr[0], 64)
			if err != nil {
				return nil, 0, err
			}
			db = db.Where("score = ?", num)
		} else {
			min, _ := strconv.ParseFloat(scoreArr[0], 64)
			max, _ := strconv.ParseFloat(scoreArr[1], 64)
			if min > max {
				min, max = max, min
			}
			db = db.Where("score >= ? and score <= ?", min, max)
		}
	}
	if debian_buster_status, ok := params["debian_buster_status"]; ok {
		db = db.Where("debian_buster_status = ?", debian_buster_status.(string))
	}
	if sort, ok := params["sort"]; ok {
		db = db.Order(fmt.Sprintf("%s desc", sort.(string)))
	}

	var total int64
	db.Count(&total)
	var list CVEList
	err := db.Offset(offset).Limit(count).Find(&list).Error
	if err != nil {
		return nil, 0, err
	}
	return list, total, nil
}

func GetcveInfo(cve, pkg, product string) (*CVE, error) {
	db := getHandle(product)
	if db == nil {
		return nil, fmt.Errorf("No db handler found for product '%s'", product)
	}
	var info CVE
	err := db.Table("cve").Where("`cve` = ? and package = ?", cve, pkg).First(&info).Error
	if err != nil {
		return nil, err
	}
	return &info, nil

}

func (cve *CVE) Update(diff map[string]interface{}, product string) error {
	db := getHandle(product)
	if db == nil {
		return fmt.Errorf("No db handler found for product '%s'", product)
	}
	return db.Model(&cve).Where("cve = ? and package = ?", cve.Cve, cve.Package).Updates(diff).Error
}

func SyncDate(file, product string) error {
	syncLock.Lock()
	defer syncLock.Unlock()
	fmt.Println("[NOTIFICATION] CVE sync start ...")

	data, err := ioutil.ReadFile(file)
	if err != nil {
		return err
	}
	var cveList *CVEList
	err = json.Unmarshal(data, cveList)
	if err != nil {
		return err
	}

	go func() {
		err := doSync(cveList, product)
		if err != nil {
			fmt.Println(err)
			return
		}
		fmt.Println("[NOTIFICATION] CVE sync end !!!")
	}()

	return nil
}

func doSync(list *CVEList, product string) error {
	handle := getHandle(product)
	if handle == nil {
		return fmt.Errorf("No db handler found for %s, abort sync.", product)

	}
	var tx = handle.Begin()
	for _, value := range *list {
		res := tx.Model(&CVE{}).Where("cve = ? and package = ?", value.Cve, value.Package).UpdateColumns(value) // ignore updated_at
		// fmt.Println(res.RowsAffected)
		err := res.Error
		if err != nil {
			tx.Rollback()
			return err
		}
		if res.RowsAffected == 0 {
			var flag bool
			tx.Model(&CVE{}).Where("cve_id = ? and package = ?", value.Cve, value.Package).Count(&flag) // 查询漏洞是否在数据库
			if flag {
				continue
			}
			if value.Status != CVEStatusFixed {
				value.Status = CVEStatusUnprocessed
			}

			arr := QueryPrePackage(product, value.Package) //查询预装
			value.Pre_installed = strings.Join(arr, ",")
			err := tx.Create(value).Error //创建
			if err != nil {
				tx.Rollback()
				return err
			}
			//(TODO): 分配维护者
		}
	}
	return tx.Commit().Error

}

func ValidKey(name string) bool {
	switch name {
	case "cve", "package", "cvss", "score", "created_at", "updated_at":
		return true
	}
	return false
}
