package db

import (
	"bufio"
	"fmt"
	"os"
	"strings"
	"sync"

	"github.com/jinzhu/gorm"
	jsongo "github.com/json-iterator/go"
)

var (
	pkgLock     sync.Mutex
	binLock     sync.Mutex
	ReleaseList = []string{"desktop", "server"}
)

//Pre-installed list
type Package struct {
	Sort    string `gorm:"primary_key" json:"sort"`
	Package string `gorm:"primary_key" json:"package"`
}
type PackageList []*Package

//Soucre - Binary correspond
type Binary struct {
	Product string `gorm:"primary_key" json:"product"`
	Source  string `gorm:"primary_key" json:"source"`
	Binary  string `gorm:"primary_key" json:"binary"`
}
type BinaryList []Binary

//Import the pre-installed packages	list of the corresponding ISO (desktop , server ....).
//Enter the corresponding system and execute commmand " dpkg-query -W -f '${Package}\n' > pre && for i in `cat pre`; do apt-cache showsrc $i | grep -w Package: | awk -F '' '{print $2}' >> pre2; done && cat pre2 | sort | uniq > package  ".
func ImportPackage(product, release, filename string) error {
	pkgLock.Lock()
	defer pkgLock.Unlock()

	f, err := os.Open(filename)
	if err != nil {
		return err
	}
	defer f.Close()
	scanner := bufio.NewScanner(f)
	scanner.Split(bufio.ScanLines)
	var pkgList PackageList
	for scanner.Scan() {
		pkgInfo := &Package{release, scanner.Text()}
		pkgList = append(pkgList, pkgInfo)
	}
	handle := getHandle(product)
	if handle == nil {
		return fmt.Errorf("No db handler found for product '%s'", product)
	}
	tx := handle.Begin()
	tx.Where("sort=?", release).Delete(&Package{})
	for _, pkg := range pkgList {
		err := tx.Model(&Package{}).Create(pkg).Error
		if err != nil {
			tx.Rollback()
			return err
		}
	}
	return tx.Commit().Error
}

/*
Get all pre-installed package list.
*/
func GetPackageList(product string) (PackageList, error) {
	var pkgList PackageList
	handle := getHandle(product)
	if handle == nil {
		return nil, fmt.Errorf("No db handler found for product '%s'", product)
	}
	handle.Find(&pkgList)
	return pkgList, nil
}

/*
Query pre-installed package.
*/
func QueryPrePackage(product, pkg string) []string {
	handle := getHandle(product)
	if handle == nil {
		return nil
	}
	var prePkg []string
	var infos PackageList
	err := handle.Model(&Package{}).Where("`package` = ?", pkg).Find(&infos).Error
	if err != nil {
		return prePkg
	}
	if len(infos) == 0 {
		return prePkg
	}
	for _, v := range infos {
		prePkg = append(prePkg, v.Sort)
	}
	return prePkg
}

/*
Read the complete source-binary list and write the vulnerable source-binary to mariadb.
Execute commmand: `cat  /var/lib/apt/lists/*_dists_eagle_*_source_Sources | grep -E 'Package:|Binary:' | awk -F ": " '{print $2}' | sed ":a;N;s/\n/:/g" | sort | uniq > source-binary`
Error: boost1.67(binary package isn't display completely, but this package not affected by the vulnerability)
*/
func ImportBinary(product, filename string) error {
	binLock.Lock()
	defer binLock.Unlock()

	f, err := os.Open(filename)
	if err != nil {
		return err
	}
	defer f.Close()
	var allBinaryList BinaryList
	scanner := bufio.NewScanner(f)
	scanner.Split(bufio.ScanLines)
	for scanner.Scan() {
		line := scanner.Text()
		arr := strings.Split(line, ":")
		arrBinaryName := strings.Split(arr[1], ",")
		for _, BinaryName := range arrBinaryName {
			if len(BinaryName) == 0 {
				continue
			}
			binaryInfo := Binary{product, arr[0], strings.TrimSpace(BinaryName)}
			allBinaryList = append(allBinaryList, binaryInfo)
		}
	}
	handle := getHandle(product)
	if handle == nil {
		return fmt.Errorf("[import binary list] No db handler found for product '%s'", product)
	}

	var cve CVEList
	err = handle.Table("cve").Select("package").Find(&cve).Error
	if err != nil {
		return err
	}
	needImportPackageList := removeCveDuplicate(cve)

	tx := handle.Begin()
	tx.Table("binary").Where("product=?", product).Delete(&Binary{})
	for _, pkg := range needImportPackageList {
		existFlag := false
		for _, bin := range allBinaryList {
			if pkg == bin.Source {
				existFlag = true
				err = bin.create(tx)
				if err != nil {
					tx.Rollback()
					return err
				}
				continue
			}
		}
		if existFlag == false {
			fmt.Println("no found the binary list of", pkg)
		}

	}
	return tx.Commit().Error
}

// create a data
func (b *Binary) create(db *gorm.DB) error {
	return db.Model(&Binary{}).Create(b).Error
}

//Remove duplicate elements in the CVE struct list, and return a list of package name.
func removeCveDuplicate(duplicateList CVEList) []string {
	resultMap := map[string]bool{}
	for _, v := range duplicateList {
		data, _ := jsongo.Marshal(*v)
		resultMap[string(data)] = true
	}
	var result []string
	for k := range resultMap {
		var t CVE
		jsongo.Unmarshal([]byte(k), &t)
		result = append(result, t.Package)
	}
	return result
}
