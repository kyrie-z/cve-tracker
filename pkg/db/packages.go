package db

import (
	"bufio"
	"fmt"
	"os"
	"sync"
)

var (
	pkgLock     sync.Mutex
	ReleaseList = []string{"desktop", "server"}
)

type Package struct {
	Sort    string `gorm:"primary_key" json:"sort"`
	Package string `gorm:"primary_key" json:"package"`
}

type PackageList []*Package

//import the pre-installed packages	list of the corresponding ISO (desktop , server ....).
//Enter the corresponding system and execute commmand " dpkg-query -W -f '${Source}\n' | sort | uniq | awk -F " " '{print $1}' > Desktop-package.list".
func ImportPackage(release, filename, product string) error {
	//判断无锁

	//读取文件
	f, err := os.Open(filename)
	if err != nil {
		fmt.Println(err)
	}
	defer f.Close()
	scanner := bufio.NewScanner(f)
	scanner.Split(bufio.ScanLines)
	var pkgList PackageList
	for scanner.Scan() {
		pkgInfo := &Package{release, scanner.Text()}
		pkgList = append(pkgList, pkgInfo)
	}
	handle := getHandle(product)
	if handle == nil {
		return fmt.Errorf("No db handler found for product '%s'", product)
	}
	tx := handle.Begin()
	tx.Where("sort=?", release).Delete(&Package{})
	for _, pkg := range pkgList {
		err := tx.Model(&Package{}).Create(pkg).Error
		if err != nil {
			tx.Rollback()
			return err
		}
	}
	return tx.Commit().Error
}

func GetPackageList(product string) (PackageList, error) {
	var pkgList PackageList
	handle := getHandle(product)
	if handle == nil {
		return nil, fmt.Errorf("No db handler found for product '%s'", product)
	}
	handle.Find(&pkgList)
	return pkgList, nil
}
