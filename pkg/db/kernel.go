package db

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/PuerkitoBio/goquery"
)

type Kernel struct {
	Cve                    string    `json:"cve" gorm:"primary_key"`
	Package                string    `json:"package" `
	Status                 string    `json:"status"`
	Cvss                   int       `json:"cvss"`
	Score                  float64   `json:"score"`
	Description            string    `json:"description"`
	Upstream_fixed_version string    `json:"upstream_fixed_version"`
	Locale_fixed_version   string    `json:"locale_fixed_version"`
	Patch_local            string    `json:"patch_local"`
	Patch_upstream         string    `json:"patch_upstream"`
	Release                string    `json:"release" gorm:"primary_key"`
	Poc                    string    `json:"poc"`
	Repairer               string    `json:"repairer"`
	Fix_at                 string    `json:"fix_at"`
	Explain                string    `json:"explain"`
	Integrate_version      string    `json:"integrate_version"`
	CreatedAt              time.Time `json:"created_at"`
	UpdatedAt              time.Time `json:"updated_at"`
}

type KernelList []*Kernel

type IntegrateInfo struct {
	Cve               string   `json:"cve"`
	Intergrateversion []string `json:"integrateversion"`
}

type IntegrateInfoList []IntegrateInfo

var (
	kernelLock sync.Mutex
)

//Get kernel list
func GetKernelList(params map[string]interface{}, offset, count int,
	product string) (KernelList, int64, error) {
	db := getHandle(product)
	if db == nil {
		return nil, 0, fmt.Errorf("No db handler found for product '%s'", product)
	}
	db = db.Table("kernel")
	if release, ok := params["release"].(string); ok {
		db = db.Where("`release` = ?", release)
	}
	if cve, ok := params["cve"].(string); ok {
		db = db.Where((fmt.Sprintf("`cve` LIKE '%%%s%%'", cve)))
	}
	if status, ok := params["status"].([]string); ok {
		db = db.Where("`status` in (?)", status)
	}
	if integrate_version, ok := params["integrate_version"].([]string); ok {
		db = db.Where("`integrate_version` in (?)", integrate_version)
	}
	if scoreStr, ok := params["score"].(string); ok {
		scoreArr := strings.Split(scoreStr, "-")
		if len(scoreArr) == 1 {
			num, err := strconv.ParseFloat(scoreArr[0], 64)
			if err != nil {
				return nil, 0, err
			}
			db = db.Where("score = ?", num)
		} else {
			min, _ := strconv.ParseFloat(scoreArr[0], 64)
			max, _ := strconv.ParseFloat(scoreArr[1], 64)
			if min > max {
				min, max = max, min
			}
			db = db.Where("score >= ? and score <= ?", min, max)
		}
	}
	if sort, ok := params["sort"]; ok {
		db = db.Order(fmt.Sprintf("%s desc", sort.(string)))
	}

	var total int64
	db.Count(&total)
	var list KernelList
	err := db.Offset(offset).Limit(count).Find(&list).Error
	if err != nil {
		return nil, 0, err
	}
	return list, total, nil
}

//Get  kernel info by "cve" and "release"
func GetKernelCveInfo(cve, release, product string) (*Kernel, error) {
	db := getHandle(product)
	if db == nil {
		return nil, fmt.Errorf("No db handler found for product '%s'", product)
	}
	var info Kernel
	err := db.Table("kernel").Where("`cve` = ? and `release` = ?", cve, release).First(&info).Error
	if err != nil {
		return nil, err
	}
	return &info, nil
}

//Update kernel info
func (cve *Kernel) Update(diff map[string]interface{}, product string) error {
	db := getHandle(product)
	if db == nil {
		return fmt.Errorf("No db handler found for product '%s'", product)
	}
	return db.Model(&cve).Where("cve = ? and `release` = ?", cve.Cve, cve.Release).Updates(diff).Error
}

//create new kernel info
func (k *Kernel) FirstOrCreate(product string) error {
	handle := getHandle(product)
	if handle == nil {
		return fmt.Errorf("No db handler found for %s, abort sync.", product)

	}
	return handle.FirstOrCreate(k).Error
}

func Fetch_linux(url, release string) (KernelList, error) {
	url = url + release + "/" + release + "_security.txt"
	res, err := http.Get(url)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()

	if res.StatusCode != 200 {
		return nil, fmt.Errorf("status code error: %d %s", res.StatusCode, res.Status)
	}
	doc, err := goquery.NewDocumentFromReader(res.Body)
	if err != nil {
		return nil, err
	}
	var List KernelList
	var flag, sign int
	var vb, vs string
	doc.Find("tr").Each(func(i int, s *goquery.Selection) {
		var info Kernel
		s.Find("td").Each(func(cellIdx int, cellEle *goquery.Selection) {
			band := cellEle.Text()
			if strings.Contains(band, "CVEs fixed in") {
				vb = strings.Replace(band, "CVEs fixed in ", "", -1)
				vb = strings.Replace(vb, ":", "", -1)
				vs = "fixed"
				if strings.Contains(vb, "92") {
					sign = 1
				}
				if sign == 1 {
					vs = "unprocessed"
				}
				if release != "4.19" {
					vs = "unprocessed"
				}
				flag = 1
			}
			if strings.Contains(band, "Outstanding") {
				vb = " "
				flag = 2
			}
			if flag == 0 {
				if strings.Contains(band, " ") == true {
					info.Package = "linux"
					info.Cve = strings.Replace(band[1:17], ":", "", -1)
					info.Cve = strings.Replace(info.Cve, " ", "", -1)
					info.Upstream_fixed_version = vb
					info.Status = vs
					if info.Status == "fixed" {
						info.Locale_fixed_version = vb
					}
					info.Release = release
					if !strings.Contains(vb, " ") {
						info.Patch_upstream = strings.Replace(band[17:58], " ", "", -1)
					}
				}
			}
			flag = 0
			if len(info.Cve) != 0 {
				List = append(List, &info)
			}
		})
	})
	return List, nil
}

func SyncIntergrateVersion(file, product string) error {
	kernelLock.Lock()
	defer kernelLock.Unlock()
	fmt.Println("[NOTIFICATION] sync kernel integrate version info start ...")

	data, err := ioutil.ReadFile(file)
	if err != nil {
		return err
	}
	var integrateList IntegrateInfoList
	err = json.Unmarshal(data, &integrateList)
	if err != nil {
		return err
	}
	go func() {
		err := doIntegrateSync(integrateList, product)
		if err != nil {
			fmt.Println(err)
			return
		}
		fmt.Println("[NOTIFICATION] sync maintainer info end !!!")
	}()

	return nil
}

// write sync kernel integrate version info to database
func doIntegrateSync(list IntegrateInfoList, product string) error {
	handle := getHandle(product)
	if handle == nil {
		return fmt.Errorf("No db handler found for %s, abort sync.", product)

	}
	var tx = handle.Begin()
	for _, value := range list {
		err := tx.Model(&Kernel{}).Where("cve = ? and `release` = 4.19", value.Cve).Updates(Kernel{Integrate_version: strings.Join(value.Intergrateversion, ",")}).Error
		if err != nil {
			tx.Rollback()
			return err
		}
	}
	return tx.Commit().Error
}
